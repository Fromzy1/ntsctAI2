import traceback
import uuid
import os
from elasticsearch import Elasticsearch, helpers
from dotenv import load_dotenv
import json
import random
from datetime import datetime, timedelta
import string
from pprint import pprint
import pickle

import OpenAIClient 
import ElasticTools
import dynGraphGen
import chart_util

load_dotenv()

#Instanciate openAI
LLM = OpenAIClient.Client()

# List of indexes
et = ElasticTools.Tools()
index_dict = et.get_indices_dict() # using dict gives access to indexes by name
#print(type(index_dict))
#print(f"List of Indexes: {index_dict}\n")

# List fields of the index we choose
myIndex = "kafka-application"
schema_fields = et.load_es_index_fields(index_dict[myIndex])
#print(f"List of fields for index {myIndex} : {schema_fields}\n")

# Get schema of the index
schema=et.get_index_schema(index_dict[myIndex])
#print(f"schema of the index: {schema}\n")

# Generate the prompt
# Open the file for the prompt in read mode
with open('prompt_1.txt', 'r') as file:
    content = file.read()
# In the content of the file replace the variable
# Here it the schema that is inserted
prompt=content.format(schema=schema)
#print(f"System Prompt: {prompt}\n")

##
## QUERY TO CHOOSE
##
 
query="what are the top 6 servers that are consuming biggest bandwidth" 
#query="what are the top 4 servers with most failures" 

print(f"Here is the query: {query}")

# Generate Elasticsearch Query
response=LLM.generate_non_streaming_response(query, system_prompt=prompt)
print(f"Here is the Elasticsearch query generated by LLM:\n {response}")
es_query=json.loads(response)
#pprint(es_query)

# Launch ES query
search_results = et.search_results(index_dict[myIndex], es_query=es_query)
total_hits = search_results['hits']['total']['value']
#print(f"Total matches: {total_hits}")

# Show the data extracted from the ES query
if "aggs"in es_query:
    data = search_results['aggregations']
    pprint(f"Here is the data found: {data}") # DICT
    #print(type(data))
else:
    data = search_results['hits']['hits']
    pprint(f"Here is the data found: {data}")
    print(type(data))

# Create the graph based on data
#dynGraphGen.process_elasticsearch_data(data, use_llm=True) 
finalChart = chart_util.ChartUtil()
finalChart.generate_chart(data)
